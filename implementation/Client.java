package merkle.implementation;import merkle.Configuration;import merkle.IClient;import merkle.IMerkleTree;import java.util.List;/** * TASK 2 * * @author Yash Gupta * @pso 17 * @date 10/29/2016 */public class Client extends IClient {    /**     * Given the path siblings this function has to verify if     * the masterHash generated by concatenating and hashing     * level by level is the same as <i>this.masterHash</i>     * You can use <i>Configuration.hashFunction</i>     */    protected boolean verifyResponse(List<IMerkleTree.Node> pathSiblings) throws Exception {        boolean matched = false;        /*         * You need to use Configuration.hashFunction and this.masterHash to determine a match         */        String checkHash;        IMerkleTree.Node parentNode;        //Check if the current index is even or odd        // if odd, we concatenate it with the next element. If odd, previous element        if(pathSiblings.get(0).getIndex() % 2 == 0) {            checkHash = Configuration.hashFunction.concatenateHash(pathSiblings.get(0), pathSiblings.get(1));            parentNode = new IMerkleTree.Node(checkHash, pathSiblings.get(0).getIndex()/2);        }        else {            checkHash = Configuration.hashFunction.concatenateHash(pathSiblings.get(1), pathSiblings.get(0));            parentNode = new IMerkleTree.Node(checkHash, pathSiblings.get(1).getIndex()/2);        }        //Since we've already gone through the first two elements, we start from 2 to the size.        for (int i = 2; i < pathSiblings.size(); i++) {            //Adding siblings to the list            if (pathSiblings.get(i).getIndex() % 2 == 0) {                checkHash = Configuration.hashFunction.concatenateHash(pathSiblings.get(i), parentNode);                parentNode = new IMerkleTree.Node(checkHash, pathSiblings.get(i).getIndex()/2);            }            else {                checkHash = Configuration.hashFunction.concatenateHash(parentNode, pathSiblings.get(i));                parentNode = new IMerkleTree.Node(checkHash, parentNode.getIndex()/2);            }        }        //Checks if the hash that the code generates is equal to the provided masterHash        if (parentNode.getHash().equals(masterHash)) {            matched = true;        }        return matched;    }}